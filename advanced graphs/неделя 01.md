Обходы графов — это способы обойти все вершины и ребра графа, в предположении, что граф связный.

# обход графа в ширину

*breadth-first search*

Сначала выбирается вершина, из которой будет производиться обход графа. Пометим ее цифрой 1.

После того, как вершина выбрана, рассматриваются все ее соседи, то есть вершины, смежные с данной.

Выберем случайную вершину из соседей и пометим ее цифрой 2 и оранжевым цветом. Продолжаем со всеми соседями вершины 1, пока они не закончатся.

Затем двигаемся в вершину с наименьшим номером, которая еще не помечалась красным. Это вершина 2. 

Снова просматриваем всех соседей вершины 2. Если кого-то до этого помечали, игнорируем. Ребро из 2 в 4 оказалось незадействованным, но его можно пометить уже использованным.

Затем двигаемся в вершину с номером 3 и помечаем ее соседей. 

И так далее, пока все вершины графа не окажутся помеченными. 
![[advanced_graphs_01_01.gif|450]]
Получается, что вершины были обойдены как-бы послойно. До первого слоя из первой вершины можно добраться за один шаг, до второго — за два, и до третьего — за три.

![[advanced_graphs_01_02.gif|450]]

Обход в ширину позволяет разбить граф на уровни. Вершины каждого уровня оказываются равноудаленными от вершины, с которой был начат обход. При этом вершины каждого слоя получают большие значения, нежели вершины предыдущего слоя.

Если учитывать только те ребра, которые использовались для обхода, то получится **дерево обхода в ширину**:
![[advanced_graphs_01_03.jpg|450]]
Это дерево обладает тем свойством, что расстояние между вершиной графа, с которой начался обход в исходном графе и любой другой вершиной, равняется расстоянию в дереве между этими двумя вершинами.

# обход графа в глубину

*depth-first search*

При обходе графа в глубину происходит движение вперед до тех пор, пока есть, куда двигаться. Если двигаться дальше некуда, то делается возврат на один шаг и производится попытка движения в другую сторону
![[advanced_graphs_01_04.gif|450]]
Откат всегда производится по тем ребрам, которые уже были пройдены, поэтому движение назад всегда однозначно.

Откат происходит до тех пор, пока не вернемся в стартовую вершину.

В результате обхода образуется два типа ребер:
- ребра DFS-дерева (в "новые" вершины)
- обратные ребра (в пройденные вершины)

На черных ребрах в графе не будет циклов.

Обратные ребра всегда ведут к вершинам, которые ближе к корню дерева (стартовой вершине).

Каждое обратное ребро вместе с путем по DFS-дереву образует *фундаментальный цикл*:
![[advanced_graphs_01_05.jpg|450]]
# потоки в сетях

Сеть — это граф, в котором выделены две вершины: одна называется источник или исток и часто обозначается буквой $s$, другая называется целью или стоком, и обозначается $t$.

Вся сеть — это некая модель транспортировки продукта. Модель, которая представлятся в виде ориентированного графа с двумя выделенными вершинами. В реальности вершин может быть выделено больше, чем две.

Предполагается, что на каждой дуге ориентированного графа задано неотрицательное число, которое называется *пропускной способностью* этой дуги, которые обозначаются как
$$c(e)\ge0$$
где $e$ — это дуга.

Потоком в сети называется некий план, описывающий, как по этой сети будет транспортироваться некий продукт из источника в сток таким образом, чтобы не превышать пропускные способности дорог или труб, которые сетью задаются. То есть, требуется указать, какое количество продукта будет перемещаться по каждой дороге в единицу времени. Это число обозначается как $f(e)$. На самом деле задается некоторая функция на дугах ориентированного графа
$$f:E\to\mathbb{R}$$
где $E$ — множество дуг. Эта функция на каждой дуге неотрицательна и не превышает пропускной способности этой дуги
$$0\ge f(e)\ge c(e)$$
Кроме того предполагается *условие сохранения потока*: если рассмотреть любую промежуточную вершину $v$ в графе, то в нее входит какое-то количество дуг и выходит некоторое количество дуг. Промежуточная вершина — это вершина не совпадающая с источником и со стоком. Предполагается, что в промежуточных вершинах никто не потребляет продукт, что происходит чистая транспортировка. Получается, что суммарное количество пришедшего в промежуточную вершину продукта равно суммарному количеству выходящего из этой же вершины продукта:
$$\sum_{e:\curvearrowright v}f(e)=\sum_{e:\curvearrowleft v}f(e)$$
Задача состоит в том, что требуется так выстроить план, указать сколько по какой дуге транспортировать, чтобы в единицу времени из $s$ в $t$ попадало максимальное количество продукта:
$$\sum_{e:\curvearrowleft s}f(e)=\sum_{e:\curvearrowright t}f(e)\to \max$$
Также может быть задача наименьшей стоимости, когда заданы не только пропускные способности дуг, но и стоимость транспортировки единицы продукта по дуге.

## верхняя граница величины потока

Например, на следующем графе черным обозначены пропускные способности, а красным — поток, который идет по дуге
![[advanced_graphs_01_06.jpg|450]]
В любой вершине поток, приходящий в нее, равен потоку, исходящему из нее. Из $s$ выходит суммарно 6, в $t$ приходит суммарно также 6. То есть, *величина потока* равна шести.

Очевидно, что из $s$ в $t$ нельзя отправить поток больший, чем сумма дуг, исходящих из $s$
$$f_{\max}\le\sum_{e:\curvearrowleft s}c(e)$$
Точно также, нельзя отправить поток, больший, чем приходит в $t$
$$f_{\max}\le\sum_{e:\curvearrowright t}c(e)$$
Как видно, поток не достигает ни левой, ни правой границы.

Разделим сеть на две части
![[advanced_graphs_01_07.jpg|450]]
Максимальное количество продукта, которое можно направить из $s$ в $t$ ограничено максимальной пропускной способностью дуг, связывающих эти две части.

*Разрез сети* — это разбиение множества вершин сети на два множества $S$ — подмножество, содержащее $s$ и $T$ — подмножество, содержащее $t$.
$$V=S\sqcup T$$
*Пропускная способность разреза* — это суммарная пропускная способность дуг, которые идут из части $S$ в часть $T$
$$\sum_{e:S\curvearrowright T}c(e)$$
$$f_\max\le c_\min$$
где $c_\min$ — пропускная способность минимального разреза сети.


# теорема Форда-Фалкерсона

Имеет место равенство
$$f_\max=c_\min$$
то есть всегда можно указать поток в сети, достигающий верхней границы.

Алгоритм Форда-Фалкерсон строит максимальный поток в сети с помощью последовательных улучшений:
- начинаем с произвольного потока
- пока можно улучшить — улучшаем
- если нельзя улучшить — останавливаемся

Допустим, есть сеть:
![[advanced_graphs_01_08.jpg|450]]
Начинаем с произвольного потока в сети. Самый простой поток — это поток, который идет по простой цепи без разветвлений.

Пример тривиального потока, который корректен относительно сети:
![[advanced_graphs_01_09.jpg|450]]
Такой поток можно найти алгоритмически следующим образом: находим любой путь из $s$ в $t$ и находим на этом пути минимальную пропускную способность дуги, и пустить по этому пути поток, с максимальным значением минимальной пропускной способности.

Допустим, проделаны какие-то шаги и есть поток в сети. 

Теперь следует построить *остаточную сеть* — сеть на том же самом множестве вершин, что и исходная сеть. Дуги в ней определяются дугами исходной сети со следующими модификациями:
- если по дуге исходной сети еще нет никакого потока, то дуга сохраняется без каких-либо изменений
- если по дуге исходной сети пущен поток, величина которого равняется пропускной способности этой дуги, то вместо нее проводим дугу в обратном направлении, у которой величина потока равна исходной величине, идущей по этой дуге
- для дуг, где не достигнут максимальный поток, исходная пропускная способность уменьшается на величину, указанную в потоке и добавляется дуга в обратном направлении с величиной потока
![[advanced_graphs_01_10.jpg|450]]
Теперь в остаточной сети ищем произвольный путь из вершины $s$ в $t$
![[advanced_graphs_01_11.jpg|450]]
Остаточная сеть допускает простое объединение полученного потока и исходного потока, по которому строили остаточную сеть. Если по какой-то дуге в первой сети шло количество продукта и в новой остаточной сети идет какое-то количество, потоки на этих дугах объединяются:
![[advanced_graphs_01_12.jpg|450]]
Результирующий поток всегда равен сумме величин потока в исходной сети и потока в остаточной сети.

Итерации проводятся до тех пор, пока в остаточной сети можно найти ненулевой поток.

Здесь не осталось ненулевых потоков
![[advanced_graphs_01_13.jpg|450]]
Теперь видно, что вершины, до которых можно дойти по ненулевым дугам из $s$ образуют подмножество $S$, а из $t$, соответственно, подмножество $T$.

Поток, по которому была построена остаточная сеть, имеет пропускную способность в точности равную пропускной способности разреза.

## теорема о целочисленности потока

- Если все пропускные способности в сети целочисленные, то и построенный алгоритмом Форда-Фалкерсона поток оказывается целочисленным (то есть $f(e)\in\mathbb{Z}$ для каждой дуги $e$).
- Если все пропускные способности в сети — рациональные дроби, то, домножив их на наименьшее общее кратное знаменателей, можно перейти к целым числам.
- Если пропускные способности в сети иррациональные, то не гарантируется, что алгоритм Форда-Фалкерсона завершится.s