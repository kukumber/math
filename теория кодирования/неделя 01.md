# алфавитное кодирование

Простейший подход:
- каждой букве языка, а также знакам препинания сопоставляем по двоичному слову
- тогда текст кодируется записью друг за другом кодов отдельных букв

Так сделано в таблицах ASCII, Unicode.

## математическая модель

Математически эту задачу можно сформулировать следующим образом. Даны алфавиты
$$\mathbb{A}=\{a_1,\ldots,a_n\},\mathbb{B}=\{b_1,\ldots,b_q\}$$
Алфавит $\mathbb{A}$ — **кодируемый**, «естественный»
Алфавит $\mathbb{B}$ — **кодовый** (например, $\mathbb{B}=\{0,1\}$)

Алфавитным кодированием называется отображение множества всех слов, записанных в естественном алфавите в множество слов, записанных в кодовом алфавите:
$$\varphi:\mathbb{A}^\ast\to\mathbb{B}^\ast$$
$^\ast$ означает, что то, что получается — это множество всевозможных слов, у которых каждый отдельный символ (каждая отдельная координата) принадлежит исходному множеству. То есть, множество $\mathbb{A}^\ast$ — это множество всех слов, у которых каждый символ взят из алфавита $\mathbb{A}$.

Отображение такое, что для любых $a_{i_1},\ldots,a_{i_r}$ выполнено:
$$\varphi(a_{i_1},\ldots,a_{i_r})=\varphi(a_{i_1})\ldots\varphi(a_{i_r})$$
Другими словами, когда кодируется слово, результат должен совпадать с кодированием букв по отдельности. То есть, достаточно определить $\varphi$ на отдельных символах алфавита $\mathbb{A}$:
$$\begin{aligned}
\varphi(a_1)&=B_1\\
\vdots\\
\varphi(a_n)&=B_n
\end{aligned}$$
Слова $B_1,\ldots,B_n$ называются **кодовыми**, совокупность $\{B_1,\ldots,B_n\}$ называется **кодом**.
Везде далее считаем, что все $B_i$ различны, иначе кодирование не однозначное

## однозначность кодирования

Кодирование $\varphi$ называется **однозначным**, если, закодировав два разных слова, записанных в естественном алфавите, будут получены два разных слова, записанных в кодовом алфавите
$$\varphi(w')\ne\varphi(w''), \text{ при } w'\ne w''$$
Однозначность не зависит от исходного алфавита $\mathbb{A}$, а целиком определяется набором  $\{B_1,\ldots,B_n\}$.

Кодирование однозначное тогда и только тогда, когда никакое слово $b_{i_1}b_{i_2}\ldots b_{i_r}$ нельзя двумя разными способами разбить на кодовые слова
![[теория кодирования/images/неделя 01.png|w50]]
В этом случае нельзя однозначно определить, какое из двух слов было закодировано $a_3a_8$ или $a_5a_1a_3$.
### достаточные условия однозначности

- **равномерность**
$$|B_1|=|B_2|=\ldots=|B_n|$$
длина всех кодовых слов одинакова

- **свойство префикса** (беспрефиксность кода)
$$\nexists i,j(i\ne j \text{ и }B_i=B_jw,\text{ где }w\in \mathbb{B}^\ast)$$
то есть, не существует двух кодовых слов таких, что одно из этих слов является префиксом другого слова

- **свойство суффикса**
$$\nexists i,j(i\ne j \text{ и }B_i=wB_j,\text{ где }w\in \mathbb{B}^\ast)$$
то есть, не существует двух кодовых слов таких, что одно из этих слов является суффиксом другого слова

Равномерность, префиксность и суффиксность не являются необходимыми условиями для однозначности. Пример:
$$\begin{aligned}
&\mathbb{A}=\{a_1,a_2\}\\
&\mathbb{B}=\{0,1\}\\
&\varphi(a_1)=0\\
&\varphi(a_2)=010
\end{aligned}$$

#### префиксные коды — «мгновенные»

Префиксные коды называются ещё **мгновенными**, так как закодированные с их помощью сообщения можно декодировать по мере приёма, без задержек
![[теория кодирования/images/неделя 01-1.png|w75]]
Если закодировать какое-то слово с помощью префиксного кода и передать по каналу связи, то адресат может начинать декодирование по мере приема данных, не дожидаясь окончания передачи.

### вывод критерия однозначности

Код неоднозначен, если найдется слово $B\in\mathbb{B}^\ast$, которое не менее чем двумя разными способами можно разбить на кодовые слова.

Рассмотрим самое короткое такое «неоднозначное» $B$ и его различные разбиения на кодовые слова:
![[теория кодирования/images/неделя 01-2.png|w50]]
Точки «верхнего» и «нижнего» разбиений, кроме крайних, все различны, иначе слово $B$ можно было бы укоротить и получить более короткое слово, которое можно неоднозначно разбить на кодовые слова:
![[теория кодирования/images/неделя 01-3.png|w75]]
Среди отрезков слова $B$, концы которых принадлежат *разным* разбиениям, *нет кодовых слов*, иначе $B$ можно было бы укоротить:
![[теория кодирования/images/неделя 01-4.png|w75]]
Минимальные отрезки слова $B$, концы которых принадлежат разным разбиениям, назовем *промежуточными*
![[теория кодирования/images/неделя 01-5.png|w50]]
Обозначим через $w_1,\ldots,w_k$ все промежуточные отрезки.

Через $\beta$ будем обозначать последовательность (возможно пустую) кодовых слов. Имеем:
$$\begin{aligned}
&\exists i,\beta(B_i=\beta w_1)\\
&\exists i,\beta(B_i=w_1\beta w_2)\\
&\vdots\\
&\exists i,j(B_i = w_{k-1}\beta w_k)\\
&\exists i,j(B_i = w_k\beta)
\end{aligned}$$
где $B_i$ — это нижнее кодовое слово (на диаграмме), $\beta$ — последовательность кодовых слов, $w_1$ — первый промежуточный отрезок.

Наоборот, пусть нашлись непустые слова $w_1,\ldots, w_k \in \mathbb{B}^\ast$, кодовые слова $B_{i_1}, \ldots, B_{i_{k+1}}$ и последовательности кодовых слов $\beta_1, \ldots, \beta_{k+1}$ такие, что выполнены соотношения:
$$\begin{aligned}
&B_{i_1} = \beta_1w_1\\
&B_{i_2} = w_1\beta_2 w_2\\
&\vdots\\
&B_{i_{k+1}} = w_k\beta_{k+1}
\end{aligned}$$
Тогда $\beta_1w_1\beta_2w_2\ldots w_{k-1}\beta_k w_k \beta_{k+1}$ декодируется не однозначно.

### критерий однозначности

Код $C=\{B_1,\ldots,B_n\}$ (множество слов) не однозначный тогда и только тогда, когда найдутся:
- непустые слова $w_1,\ldots,w_k\in\mathbb{B}^\ast \backslash C$, которые берут начало из промежуточных отрезков
- кодовые слова $B_{i_1},\ldots,B_{i_{k+1}}$
- последовательности кодовых слов $\beta_1,\ldots,\beta_{k+1}$
такие, что $k\ge1$ и выполнены соотношения
$$\begin{aligned}
&B_{i_1} = \beta_1w_1\\
&B_{i_2} = w_1\beta_2 w_2\\
&\vdots\\
&B_{i_{k+1}} = w_k\beta_{k+1}
\end{aligned}$$
(или $k=0$ и $B_{i_1}=\beta_1$, где $\beta_1$ составлено не менее, чем из двух кодовых слов).

Если $k=0$, то нет непустых слов, есть только некоторое слово $B_{i_1}$ и последовательность кодовых слов $\beta_1$. В этом случае код не является однозначным.

### графовая формулировка

Пусть $C=\{B_1,\ldots,B_n\}$ — код, который нужно проверить.

Строим орграф 
$$G_C=(V,E)$$где 
$$V=\{\varepsilon\}\cup\{\text{слова из } \mathbb{B}^\ast\backslash C\text{, являющиеся началами и концами кодовых слов}\}$$
Промежуточные отрезки — это специальные отрезки в неоднозначном слове, у которых концы являются концами в разных разбиениях: в верхнем и нижнем. То есть отрезок одновременно попадает в конец какого-то слова сверху и в конец какого-то кодового слова снизу. То есть $\{\text{слова из } \mathbb{B}^\ast\backslash C\text{, являющиеся началами и концами кодовых слов}\}$ — это потенциально все слова в кодовом алфавите, которые имеют шансы стать промежуточными отрезками. Это множество конечно, потому что исходное множество кодовых слов конечно, у каждого слова конечная длина, начал кодовых слов — ограниченное количество.

$\{\varepsilon\}$ — пустое слово, имеющее длину ноль. Конкатенация пустого слова с любым другим равна этому другому слову.

Дуга будет проведена между парой вершин (вершина — это слово)
$$E=\big\{(\alpha',\alpha'')|\exists\beta\in C^\ast\big(\alpha'\beta\alpha''\in C \text{ и } (\beta\ne\varepsilon \text{ или }\varepsilon\notin\{\alpha',\alpha''\})\big)\big\}$$
$C^\ast$ — это множество последовательностей, у которых каждый элемент — это кодовое слово.

То есть, должна найтись последовательность кодовых слов такая, что кодовым является слово, начинающееся с $\alpha'$, в середине которого находится $\beta$, заканчиваться слово должно на $\alpha''$, и при этом должно быть выполнено следующее: либо эта последовательность $\beta$ непустая, либо $\alpha'$ и $\alpha''$ — непустые.

Как только построен такой граф, можно проверить однозначность кода, проверив, есть ли в графе ориентированный цикл, проходящий через вершину $\varepsilon$. Код $C$ однозначный $\Leftrightarrow$ в $G_C$ нет орцикла через вершину $\varepsilon$.