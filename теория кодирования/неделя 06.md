# декодирование линейных кодов. Задача NCP (Nearest Codeword Problem)

**Даны**:
- линейный код $C\in \mathbb{F}_2^n$ (задан порождающей матрицей)
- слово $\mathbf{b}\in \mathbb{F}_2^n$

Требуется найти $\mathbf{a}^\ast \in C$, такое, что 
$$d(\mathbf{a}^\ast,\mathbf{b})=\min_{\mathbf{a}\in C}d(\mathbf{a},\mathbf{b})$$

**Теорема**
Задача NCP является NP-трудной.

Для доказательства построим сведения:
$$3\text{-SAT}\to1\text{-in-}3\text{-SAT}\to\text{NCP}$$
$3\text{-SAT}$ = $3\text{-SATISFABILITY}$
$1\text{-in-}3\text{-SAT}$ = $\text{exactly-}1\text{-in-}3\text{-SATISFABILITY}$

## задача 3-SAT

**Дан** набор скобок, в каждой из которых ровно три логических литерала ($x$ или $\overline{x}$, где $x$ — логическая переменная, $\overline{x}$ — отрицание логической переменной).

**Определить**, можно ли присвоить переменным значения 0 и 1, так, чтобы в каждой скобке оказался ***хотя бы один*** истинный литерал.

Эта задача может быть сформулирована как задача о выполнимости конъюктивных нормальных форм, то есть конъюнции, или логического произведения нескольких выражений, каждое из которых является дизъюнкцией
$$(x\vee y \vee z)\cdot(x\vee \overline{w}\vee z)\cdot(a \vee b\vee c )$$
Можно ли найти такие переменные, при которых эта конъюнкция превращается в истинную. Конъюнкция обращается в истину тогда и только тогда, когда все операнды обращаются в истину. Каждая скобка содержит дизъюнкцию, которая обращается в истину тогда, когда хотя бы один из операндов обращается в истину.

## задача 1-in-3-SAT

**Дан** набор скобок, в каждой из которых ровно три логических литерала ($x$ или $\overline{x}$, где $x$ — логическая переменная, $\overline{x}$ — отрицание логической переменной).

**Определить**, можно ли присвоить переменным значения 0 и 1, так, чтобы в каждой скобке оказался ***ровно*** один истинный литерал.

### 3-SAT → 1-in-3-SAT

Пусть дан набор скобок для задачи $3\text{-SAT}$.

Заменяем $(x\vee y\vee z)$ на $[\overline{x}, p, q],[q,y,r],[r,s,\overline{z}]$, так, чтобы переменные $p,q,r,s$ нигде больше не встречались.

Пример:
$$(x_1\vee x_2 \vee x_3)(\overline{x}_1\vee x_3\vee x_4)$$
заменится на:
$$\begin{aligned}
&[\overline{x}_1,p_1,q_1][q_1,x_2,r_1][r_1,s_1,x_3] \\
&[x_1,p_2,q_2][q_2,x_3,r_2][r_2,s_2,\overline{x}_4]
\end{aligned}$$

Если для исходного набора скобок есть набор переменных, на котором в каждой скобке есть хотя бы одно истинное значение, то нужно, чтобы из порожденного набора из скобок существовал набор значений переменных такой, что в каждой скобке ровно одно истинное значение.

**Утверждение**:
В скобке вида $(x\vee y\vee z)$ есть **хотя бы один** истинный литерал, тогда и только тогда, когда найдутся такие $p,q,r,s$, что в каждой из скобок $[\overline{x}, p, q],[q,y,r],[r,s,\overline{z}]$ был **ровно** один истинный литерал.

| $\mathbf{(x,y,z)}$  | $\mathbf{[\overline{x},p,q][q,y,r][r,s,\overline{z}]}$ | $\mathbf{(p,q,r,s)}$ |
|---|---|---|
| $(0,0,0)$ | $[1,p,q][q,0,r][r,s,1]$ | ?! |
| $(0,0,1)$ | $[1,p,q][q,0,r][r,s,0]$ | $(0,0,1,0)$ |
| $(0,1,0)$ | $[1,p,q][q,1,r][r,s,1]$ | $(0,0,1,0)$ |
| $(0,1,1)$ | $[1,p,q][q,1,r][r,s,0]$ | $(0,0,0,1)$ |
| $(1,1,0)$ | $[0,p,q][q,1,r][r,s,1]$ | $(1,0,0,0)$ |
| $(1,0,1)$ | $[0,p,q][q,0,r][r,s,0]$ | $(0,1,0,1)$ |
| $(1,1,1)$ | $[0,p,q][q,1,r][r,s,0]$ | $(1,0,0,1)$ |

### 1-in-3-SAT → NCP

Нужно по набору скобок, подающемуся на вход задаче $1\text{-in-}3\text{-SAT}$ нужно указать вход для задачи $NCP$, то есть матрицу, которая является порождающей для какого-то линейного кода и слово $\mathbf{b}$, для которого нужно найти ближайшее кодовое слово.

Пусть в задаче $1\text{-in-}3\text{-SAT}$ всего $N$ переменных и $M$ скобок.

длина кода будет:
$$n:=(M+1)(M+N)+3M$$
размер матрицы
$$k:=2N$$
блоки матрицы $G$
$$G:=(G_1|G_1|\ldots|G_1|G_2|G_2|\ldots|G_2|G_3)$$
вектор $\mathbf{b}$
$$\mathbf{b}:=(11111111\ldots 1|00000000\ldots 0)$$

Матрица $G_1\in\mathbb{F}^{2N\times N}_2$ содержит строк вдвое больше, чем переменных, и каждая строка соответствует литералу
$$\begin{aligned}
x_1 \to \ & 1 \  0 \ \cdots \ 0 \\
\overline{x}_1 \to \ &1 \ 0 \ \cdots \  0 \\
x_2\to \ &0 \ 1 \ \cdots \ 0 \ \\
\overline{x}_2\to \ &0 \ 1 \ \cdots \ 0\\
&\vdots \  \vdots \ \  \ddots \ \  \vdots \ \\
x_N \to \ &0 \ 0 \ \cdots \ 1 \\
\overline{x}_N \to \ & 0 \ 0 \ \cdots \ 1
\end{aligned}$$
Матрица $G_2\in\mathbb{F}^{2N\times M}_2$ связывает переменные со скобками
![[неделя 06.png|w70]]
В этой матрице $2N$ строк и $M$ столбцов (по одному столбцу на каждую скобку). В каждом столбце ровно три единицы, стоящих на пересечении столбца и строчек, соответствующих литералам, входящим в скобку.

Матрица $G_3\in\mathbb{F}^{2N\times 3M}_2$ также связывает переменные со скобками
![[неделя 06-1.png|w70]]
Но в $G_3$ единицы разнесены в три разных столбца, поэтому в каждом столбце ровно по одной единице.

Пример $G$ и $\mathbf{b}$ для задачи $[x_1, \overline{x}_2,x_3][\overline{x}_1,x_3, \overline{x}_4]$.

$$\begin{aligned}
x_1 \to \ & \mathbf{1} \  0  \ 0 \ 0 \ \cdots \ 1 \ 0 \ \cdots \ 1 \ 0 \ 0 \ 0 \ 0 \ 0 \\ 
\overline{x}_1 \to \ & \mathbf{1} \ 0 \ 0 \ 0 \ \cdots \ 0 \ 1 \ \cdots \ 0 \ 0 \ 0 \ 1 \ 0 \ 0  \\
x_2\to \ &0 \ \mathbf{1} \ 0 \ 0 \ \cdots \ 0 \ 0  \ \cdots \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \\
\overline{x}_2\to \ &0 \ \mathbf{1} \ 0 \ 0 \  \cdots \ 1 \ 0 \ \cdots \ 0 \ 1 \ 0 \ 0 \ 0 \ 0  \\
x_3 \to \ &0 \ 0 \ \mathbf{1} \ 0 \  \cdots \ 1 \ 1 \ \cdots \ 0 \ 0 \ 1 \ 0 \ 0 \ 1 \\
\overline{x}_3 \to \ & 0 \ 0 \ \mathbf{1} \ 0 \ \cdots \ 0 \ 0  \ \cdots \ 0 \ 0 \ 0 \ 0 \ 0  \ 0 \\
x_4 \to \ &0 \ 0 \ 0 \ \mathbf{1} \  \cdots \ 0 \ 0  \ \cdots \ 0 \ 0 \ 0 \ 0 \ 0 \ 0  \\
\overline{x}_4 \to \ & 0 \ 0 \ 0 \ \mathbf{1} \ \cdots \ 0 \ 1 \ \cdots \ 0 \ 0 \ 0 \ 0 \ 0 \ 1 \\
\mathbf{b}\to \ & 1 \ 1 \ 1 \ 1 \ \cdots \ 1 \ 1 \ \cdots \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 
\end{aligned}$$
Четыре переменные, поэтому  в матрице восемь строк — по две на каждую переменную. Матрица $G_1$ — почти единичная матрица. 

$G_2$ содержит два столбца, потому что две скобки. $G_3$ содержит по три столбца на каждую скобку.

Так как скобок две, то значит, что копий матриц $G_1$ и $G_2$ по $M+1=3$ соответственно.

Допустим, набор значений переменных $[x_1, \overline{x}_2,x_3][\overline{x}_1,x_3, \overline{x}_4]$ 
$$x_1=x_2=1,x_3=x_4=0$$
Если мы возьмем в матрице $G$ строчки, соответствующие литералам, обращающимся в единицу на этом наборе значений:
$$\begin{aligned}
x_1 \to \ & \mathbf{1} \  0  \ 0 \ 0 \ \cdots \ 1 \ 0 \ \cdots \ 1 \ 0 \ 0 \ 0 \ 0 \ 0 \\ 
x_2\to \ &0 \ \mathbf{1} \ 0 \ 0 \ \cdots \ 0 \ 0  \ \cdots \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 \\
\overline{x}_3 \to \ & 0 \ 0 \ \mathbf{1} \ 0 \ \cdots \ 0 \ 0  \ \cdots \ 0 \ 0 \ 0 \ 0 \ 0  \ 0 \\
\overline{x}_4 \to \ & 0 \ 0 \ 0 \ \mathbf{1} \ \cdots \ 0 \ 1 \ \cdots \ 0 \ 0 \ 0 \ 0 \ 0 \ 1 
\end{aligned}$$
и возьмем линейную комбинацию этих строк:
$$\begin{aligned}
& 1 \  1  \ 1 \ 1 \ \cdots \ 1 \ 1 \ \cdots \ 1 \ 0 \ 0 \ 0 \ 0 \ 1  \\
\mathbf{b}\to \ & 1 \ 1 \ 1 \ 1 \ \cdots \ 1 \ 1 \ \cdots \ 0 \ 0 \ 0 \ 0 \ 0 \ 0 
\end{aligned}$$
то в подматрицах $G_1$ и $G_2$ она полностью совпадает с вектором $\mathbf{b}$. В результате расстояние между $G$ и вектором $\mathbf{b}$ будет равно 2.

Матрица $G_1$ контролирует выбор значений переменных, чтобы из каждых двух противоположных значений было выбрано ровно одно.

Матрица $G_2$ контролирует, чтобы из каждой скобки ровно один или ровно три литерала обращались в истину.

Матрица $G_3$ контролирует, чтобы из каждой скобки ровно один литерал обратился в истину. Для того, чтобы расхождение с вектором $\mathbf{b}$ совпадало с числом скобок.


**утверждение**
Пусть вектор $\mathbf{a}$ является линейной комбинацией строк построенной ранее матрицы $G$. Тогда $d(\mathbf{a},\mathbf{b})\ge M$, причем $d(\mathbf{a},\mathbf{b})=M$ тогда и только тогда, когда вектор $\mathbf{a}$ соответствует решению задачи 1-in-3-SAT.

Следовательно, задача 1-in-3-SAT полиномиально сводится к задаче NCP.

# коды Рида—Соломона

Пусть $k\le n\le q$. Пусть некоторые точки $t_1, \ldots, t_n \in \mathbb{F}_q$ — фиксированные, попарно различные, поэтому их количество не превосходит количество элементов поля $q$. Можно построить код, длина слов которого равна $n$, а размерность равна произвольному, наперед заданному числу $k$, которое не больше длины кодовых слов.
$$C:=\big\{(P(t_1),\ldots,P(t_n))|P\in\mathbb{F}_q[x]\wedge\deg P <k\big\}$$
Рассмотрим всевозможные многочлены с коэффициентами из поля $\mathbb{F}_q$, то есть это выражения вида:
$$c_0+c_1x+c_2x^2 + \ldots + c_{k-1}x^{k-1}$$
последний элемент с индексом $(k-1)$, потому что степени многочленов меньше $k$. Понятно, что если вместо $x$ подставлять элементы поля $\mathbb{F}_q$, то многочлен будет также элементом поля $\mathbb{F}_q$.

Берем многочлен и вычисляем последовательно в точках $t_1, \ldots t_n$. Получаем значение многочлена в $n$ разных точках поля и эти значения образуют одно кодовое слово. Код будет состоять из всевозможных слов, построенных по всевозможным многочленам ограниченной степени меньше $k$.

Этот код $C$ будет линейным. Можно проверить линейную комбинацию любых двух слов, которая также должна быть кодовым словом:
$$\alpha \cdot\big(P_1(t_1),\ldots,P_1(t_n)\big)+\beta\cdot\big(P_2(t_1),\ldots,P_2(t_n)\big)=$$
вносим $\alpha$ и $\beta$ в каждую из компонент вектора
$$=\big((\alpha P_1+\beta P_2)(t_1),\ldots,(\alpha P_1+\beta P_2)(t_n)\big)$$

Оценим кодовое расстояние исходя из стандартных алгебраических утверждений. Если многочлен ненулевой тождественно и имеет степень меньше $k$, значит степень его не превосходит $(k-1)$, тогда корней у него может быть тоже не больше $(k-1)$ по теореме Лагранжа.

Соответственно, среди значений $(P(t_1),\ldots,P(t_n))$ не более, чем $(k-1)$ значение нулевое. Всего значений $n$. Значит ненулевых значений остается как минимум 
$$n-(k-1)=n-k+1$$
Теперь найдем размерность кода, как линейного пространства. Докажем, что разным многочленам $P$ соответствуют разные кодовые слова. Допустим, взяты два разных многочлена и совпали два кодовых кода:
$$(P_1(t_1),\ldots,P_1(t_n))=(P_2(t_1),\ldots,P_2(t_n))$$
Это означает, что разность этих двух кодовых слов равна нулевому вектору:
$$\big((P_1-P_2)(t_1),(P_1-P_2)(t_2),\ldots,(P_1-P_2)(t_n)\big)=\mathbf{0}$$
Это значит, что у многочлена $(P_1-P_2)$ оказалось $n$ корней. Степень многочлена не превосходит $k$, а $k$ не превосходит $n$. Получилось, что корней строго больше, чем степень многочлена. Это не может быть, если многочлен не тождественный ноль. Противоречие.

Многочлен определяется набором коэффициентов, каждый из которых может быть выбран $q$  способами, а всего коэффициентов $k$ штук. Всего многочленов $q^k$. Получается $q^k$ различных кодовых слов.

Если взять взять многочлен, равный константе $P=1$
$$(1, \ldots 1)$$
$P=x$
$$t_1, \ldots, t_n$$
$P=x^2$
$$t_1^2, \ldots, t_n^2$$
и так далее, вплоть до $(k-1)$
$$t_1^{k-1}, \ldots, t_n^{k-1}$$
Это все линейно независимые слова, потому что $t_1, \ldots, t_n$ — это различные элементы поля. Есть лемма Вандермонда о том, что если брать такие слова вплоть до $n$, то получится матрица Вандермонда, определитель которой отличен от нуля. То есть все такие строчки линейно независимы. Найден базис размера $k$.

## исправление ошибок

Так как $d(C) = n- k + 1$, то код может исправлять $\lfloor\frac{n-k}{2}\rfloor$ ошибок.

Постановка задачи декодирования:
- дано искаженное кодовое слово кода Рида-Соломона, то есть значение некоторого многочлена в известных нам точках поля $(\hat{p}_1, \ldots, \hat{p}_n)\in\mathbb{F}_q^n$ 
- найти $p\in\mathbb{F}_q[x]$, такой, что $\deg P \le k-1$ и количество тех позиций, в которых значение многочлена в точке $t_i$ отличается от принятого значения $\hat{p}_i$ было не слишком большим:
$$\# \{i | P(t_i)\ne \hat{p}_i\}\le\bigg\lfloor\frac{n-k}{2}\bigg\rfloor$$

### алгоритм Берлекэмпа—Велча

Дано $(\hat{p}_1, \ldots, \hat{p}_n)\in\mathbb{F}_q^n$ 
Найти $P: \deg P< k\wedge \# \{i | P(t_i)\ne\hat{p}_i\}\le \frac{n-k}{2}$

Многочлен ошибок $E(x)$, как произведение разностей $(x-t_i)$ по индексам, в которых исказилось передаваемое слово:
$$E(x):=\prod_{i: P(t_i)\ne\hat{p}_i}(x-t_i)$$
Если бы этот многочлен был известен, то его корни показали бы разряды, в которых произошли ошибки.

Вспомогательный многочлен:
$$U(x):=E(x) \cdot P(x)$$
Оба многочлена $E(x)$ и $U(x)$ равны нулю тогда, когда в них подставляем точки поля такие, что в этих точка значение многочлена при передаче исказились.

Заметим, что степень многочлена $E(x)$ — это в точности количество разрядов, в которых произошла ошибка:
$$\deg E=s$$
Коэффициент при мономе старшей степени равен единице:
$$\text{coef}_{x^s}E=1$$
где:
$$s:=\#\{i|P(t_i)\ne\hat{p}_i\}$$
Степень многочлена $U(x)$ ограничена величиной:
$$\deg U\le \deg E+ \deg P\le s + k - 1$$
Для любого $i \in \{1, \ldots, n\}$ выполнено равенство:
$$U(t_i) = E(t_i)\cdot \hat{p}_i$$
Если взять точку $t_i$, в которой не произошло искажение значения, то $\hat{p}_i=P(t_i)$ и это равенство получается как следствие определения $U(x)$. Если же значение отличается $\hat{p}_i\ne P(t_i)$, то в этой точке многочлены $E(x)$ и $U(x)$ обнулятся.

Попытаемся найти какие-то многочлены $\widetilde{E}$ и $\widetilde{U}$, для которых:
- $\deg \widetilde{E} = s$ и $\text{coef}_{x^s}\widetilde{E}=1$, где $s\le (n-k)/2$
- $\deg\widetilde{U}\le s + k - 1$
- для любого $i \in \{1, \ldots, n\}$ выполнено равенство:
$$\widetilde{U}(t_i) = \widetilde{E}(t_i)\cdot \hat{p}_i$$

Зафиксируем $s$ и положим $\widetilde{E}$:
$$\widetilde{E}=x^s+\sum_{j\le s-1}e_jx^j$$
и $\widetilde{U}$:
$$\widetilde{U}=\sum_{j\le s+k-1}u_jx^j$$
где $e_0, \ldots, e_{s-1},u_0, \ldots, u_{s+k-1}$ — неопределенные коэффициенты.
$$\begin{cases}
\hat{p}_1t_1^s=\sum_{0\le j \le s-1}\hat{p}_1e_jt_1^j=\sum_{0\le j \le k+ s-1}u_jt^j_1 \\
\ \vdots \\
\hat{p}_nt_n^s=\sum_{0\le j \le s-1}\hat{p}_ne_jt_n^j=\sum_{0\le j \le k+ s-1}u_jt^j_n
\end{cases}$$
Получилась система линейных уравнений относительно $e_j$ и $u_j$. При решении системы при каком-то $s$ будут получены $\widetilde{E}$ и $\widetilde{U}$.

Допустим, $\widetilde{E}$ и $\widetilde{U}$ найдены.

Если это те самые $\widetilde{E}$ и $\widetilde{U}$, то можно сразу найти $P(x)=\frac{\widetilde{E}(x)}{\widetilde{U}(x)}$ .

**утверждение**

Если пары $(E_1, U_1)$ и $(E_2, U_2)$ удовлетворяют системе
- $\deg \widetilde{E} = s$ и $\text{coef}_{x^s}\widetilde{E}=1$, где $s\le (n-k)/2$
- $\deg\widetilde{U}\le s + k - 1$
- для любого $i \in \{1, \ldots, n\}$ выполнено равенство:
$$\widetilde{U}(t_i) = \widetilde{E}(t_i)\cdot \hat{p}_i$$
то
$$\frac{U_1}{E_1}\equiv\frac{U_2}{E_2}$$
А это значит, что 
$$\frac{U}{E}\equiv\frac{U_1}{E_1}\equiv\frac{U_2}{E_2}$$
То есть любое решение системы дает искомый многочлен.

**доказательство**

Возьмем две пары многочленов  $(E_1, U_1)$ и $(E_2, U_2)$ удовлетворяющих системе. 

Рассмотрим произведение $U_1E_2$. Его степень:
$$\deg U_1E_2\le \deg U_1 + \deg E_2\le\bigg(\frac{n-k}{2}+k - 1\bigg)+\frac{n-k}{2}\le n -1$$
Аналогично $U_2E_1\le n - 1$.

Далее, для любого $i$ имеем:
$$U_1(t_i)E_2(t_i)=(\hat{p}E_1(t_i)\big)E_2(t_i)=E_1(t_i)\big(\hat{p}_i E_2(t_i)\big)=E_1(t_i)U_2(t_i)$$

Мы установили, что 
- $\deg(U_1E_2-E1U_2)\le n- 1$
- $U_1(t_i)E_2(t_i)-E_1(t_i)U_2(t_i)=0$ для $i=1,\ldots,n$

Корней у многочлена оказалось больше, чем ограничений на его степень. Значит этот многочлен тождественно равный нулю:
$$U_1E_2\equiv E_1U_2$$
отсюда следует пропорция:
$$\frac{U_1}{E_1}\equiv\frac{U_2}{E_2}=\frac{U}{E}=P$$

